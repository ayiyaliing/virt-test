# Do not edit, auto generated file from subtests config
variants subtest:
    - unattended_install:
        virt_test_type = qemu libvirt
        type = unattended_install
        start_vm = no
        kill_vm = yes
        kill_vm_gracefully = yes
        kill_vm_on_error = yes
        shutdown_cleanly = yes
        shutdown_cleanly_timeout = 120
        force_create_image = yes
        guest_port_unattended_install = 12323
        kernel = vmlinuz
        initrd = initrd.img
        # Throw errors if guest screen is inactive
        inactivity_watcher = error
        # Inactivity treshold to error the test
        inactivity_treshold = 1800
        # Set migrate_background to yes to run migration in parallel
        # migrate_background = yes
        image_verify_bootable = no
        # Copy boot image to results dir or not
        # boot image will include the ks file or other files you need
        # during install. Could be helpful to debug the install failed
        # reasons.
        # store_boot_disk = yes
        #
        # Backup images from nfs when install failed
        image_copy_on_error = no
        # images_good =
        # Mount point for your back up images
        # dst_dir =
        #
        # This value is setup for huge page set up.
        # Lowest memory size for on vm to finish install test based on the
        # anaconda memory check size. Tested it with RHEL, Windows and newest
        # Fedora guests. For other guests like ubuntu if your install failed with
        # don't have enough RAM error from anaconda, please enlarge this value.
        lowest_mem = 512
        variants:
            - aio_native:
                image_aio = native
            - aio_threads:
                image_aio = threads
        # Add some special types of installation
        variants:
            - default_install:
                # Installation without any special configuration
            - perf:
                # configuration for performance test
            - multi_disk_install:
                no ide
                only unattended_install..cdrom
                images += " stg stg2 stg3 stg4 stg5 stg6 stg7 stg8 stg9 stg10 stg11 stg12 stg13 stg14 stg15 stg16 stg17 stg18 stg19 stg20 stg21 stg22 stg23 stg24"
                image_name_stg = images/storage
                image_name_stg2 = images/storage2
                image_name_stg3 = images/storage3
                image_name_stg4 = images/storage4
                image_name_stg5 = images/storage5
                image_name_stg6 = images/storage6
                image_name_stg7 = images/storage7
                image_name_stg8 = images/storage8
                image_name_stg9 = images/storage9
                image_name_stg10 = images/storage10
                image_name_stg11 = images/storage11
                image_name_stg12 = images/storage12
                image_name_stg13 = images/storage13
                image_name_stg14 = images/storage14
                image_name_stg15 = images/storage15
                image_name_stg16 = images/storage16
                image_name_stg17 = images/storage17
                image_name_stg18 = images/storage18
                image_name_stg19 = images/storage19
                image_name_stg20 = images/storage20
                image_name_stg21 = images/storage21
                image_name_stg22 = images/storage22
                image_name_stg23 = images/storage23
                image_name_stg24 = images/storage24
                image_name_stg25 = images/storage25
                image_size_equal = 1G
            - large_image:
                only unattended_install.cdrom
                only qcow2 qcow2v3
                image_size_image1 = 2300G
                image_size = 2300G
            - with_migration:
                migrate_background = yes
            - setting_cluster_size:
                # qemu-kvm bug 812705
                no Host_RHEL.5
                image_cluster_size = 4096
                only qcow2 qcow2v3
        # Way of delivering ks file into the guest
        variants:
            # Additional iso with kickstart is attached into the guest
            - extra_cdrom_ks:
                only Linux
                unattended_delivery_method = cdrom
                cdroms += " unattended"
                drive_index_unattended = 1
                drive_index_cd1 = 2
            # Kickstart is packed into the installation iso
            - in_cdrom_ks:
                only Linux, unattended_install.cdrom
                unattended_delivery_method = integrated
            # Autotest starts simple http server providing kickstart
            - http_ks:
                only Linux
                unattended_delivery_method = url
            # Image with kickstart is attached into the guest as floppy drive
            - floppy_ks:
                unattended_delivery_method = floppy
            # Only perform a libvirt import. No cdroms, no floppies, no nothing
            - import:
                virt_test_type = libvirt
                no cdrom, url, nfs, remote_ks, pxe, kernel_initrd
                cdroms = ""
                floppy = ""
                timeout = 180
        variants:
            # Install guest from cdrom
            - cdrom:
    
                # set copy_to_local if you want copy files from nfs to local host before testing.
                # local_dir: local folder used to save nfs file, kvm folder will be used by default.
                # Both absolute path and relative path are supported in local_dir
                # local_dir = /root/
                # copy_to_local = cdrom_cd1 cdrom_winutils
    
                # TODO: is this needed for both kvm and libvirt?
                # This option is only used in windows installation case,
                # since linux use kernel/initrd option of qemu.
                boot_once = d
                medium = cdrom
                redirs += " unattended_install"
            # Install guest from http/ftp url
            - url:
                only Linux
                medium = url
                url = REPLACE_THIS_WITH_TREE_URL
            # Install guest from nfs nfs_server:nfs_dir
            - nfs:
                only Linux
                medium = nfs
                nfs_server = REPLACE_THIS_WITH_NFS_SERVER
                nfs_dir = REPLACE_THIS_WITH_NFS_DIRECTORY
            # Install guest with a remote kickstart
            - remote_ks:
                only Linux
                medium = url
                # TODO: does kvm need to prefix this with '--append'?
                extra_params = " ks=REPLACE_THIS_WITH_URL_OF_KS"
                url = REPLACE_THIS_WITH_TREE_URL
            # Install guest using pxe/tftp  (virt-install --pxe)
            - pxe:
                only Linux
                medium = pxe
            # Install guest using kernel/initrd pair from directory
            - kernel_initrd:
                only Linux
                medium = kernel_initrd
            - import:
                virt_test_type = libvirt
                no extra_cdrom_ks, in_cdrom_ks, http_ks, floppy_ks
                medium = import
                force_create_image = no
                create_image = no
    - @type_specific:
        variants subtest:
            - boot_from_device:
                virt_test_type = esx
                no Host_RHEL.5, Host_RHEL.6.0, Host_RHEL.6.1, Host_RHEL.6.2
                type = boot_from_device
                boot_menu = on
                enable_sga = yes
                image_boot = no
                virt_test_type = esx
                boot_menu_key = "f12"
                boot_menu_hint = "Press F12 for boot menu"
                boot_fail_info = "Booting from Hard Disk...;"
                boot_fail_info += "Boot failed: not a bootable disk"
                variants:
                    - boot_from_hard_drive:
                        dev_name = hard-drive
                        bootindex_image1 = 1
                    - boot_from_usb_stg:
                        dev_name = usb-storage
                        usb_devices = ""
                        usbs = usb1
                        usb_type_usb1 = usb-ehci
                        images += " stg"
                        image_name_stg = "images/usbdevice"
                        image_format_stg = "qcow2"
                        drive_format_stg = "usb2"
                        image_size_stg = 100M
                        create_image_stg = yes
                        remove_image_stg = yes
                        variants:
                            - with_new_device:
                                bootindex_stg = 1
                            - with_specify_device:
                                # Specify the boot device name which you want to test here.
                                boot_device = "USB MSC Drive"
                    - boot_from_scsi_hd:
                        dev_name = scsi-hd
                        drive_format_image1 = scsi-hd
                        variants:
                            - with_local_device:
                                bootindex_image1 = 1
                            - with_new_device:
                                images = " stg"
                                image_name_stg = "images/scsidevice"
                                image_format_stg = "qcow2"
                                drive_format_stg = scsi-hd
                                image_size_stg = 1G
                                create_image_stg = yes
                                remove_image_stg = yes
                                bootindex_stg = 1
                            - with_specify_device:
                                boot_device = "virtio-scsi Drive"
                    - boot_from_scsi_cdrom:
                        start_vm = no
                        dev_name = scsi-cd
                        cdroms = "test"
                        cdrom_test = /tmp/test.iso
                        cd_format = scsi-cd
                        boot_fail_info = "Booting from DVD/CD...;"
                        boot_fail_info += "Boot failed: Could not read from CDROM"
                        variants:
                            - with_local_iso:
                                bootindex_test = 1
                            - with_specify_device:
                                boot_device = "DVD/CD"
                    - boot_from_iscsi_device:
                        start_vm = no
                        dev_name = iscsi-dev
                        portal_ip = 10.66.90.100
                        initiator = "iqn.2010-07.com.redhat:kvmautotest"
                        target = "iqn.2001-05.com.equallogic:0-8a0906-db31f7d03-470263b05654c204-kvm-puyiqiao"
                        images = "stg"
                        image_name_stg = "/dev/sdb"
                        image_format_stg = ""
                        drive_format_stg = scsi-block
                        variants:
                            - with_remote_stg:
                                bootindex_stg = 1
                            - with_specify_device:
                                boot_device = "virtio-scsi Drive"
            
            - esx_unattended:
                virt_test_type = esx
                virt_test_type = esx
                type = esx_unattended
                start_vm = no
                kill_vm = yes
                kill_vm_gracefully = yes
                kill_vm_on_error = yes
                shutdown_cleanly = yes
                shutdown_cleanly_timeout = 120
                force_create_image = yes
                guest_port_esx_unattended = 12323
                kernel = vmlinuz
                initrd = initrd.img
                # Throw errors if guest screen is inactive
                inactivity_watcher = error
                # Inactivity treshold to error the test
                inactivity_treshold = 1800
                # Set migrate_background to yes to run migration in parallel
                # migrate_background = yes
                image_verify_bootable = no
            
                # Way of delivering ks file into the guest
                variants:
                    # Additional iso with kickstart is attached into the guest
                    - extra_cdrom_ks:
                        only Linux
                        unattended_delivery_method = cdrom
                        cdroms += " unattended"
                        drive_index_unattended = 1
                        drive_index_cd1 = 2
                    # Kickstart is packed into the installation iso
                    - in_cdrom_ks:
                        only Linux, esx_unattended.cdrom
                        unattended_delivery_method = integrated
                    # Autotest starts simple http server providing kickstart
                    - http_ks:
                        only Linux
                        unattended_delivery_method = url
                    # Image with kickstart is attached into the guest as floppy drive
                    - floppy_ks:
                        only Linux
                        unattended_delivery_method = floppy
                        local_ip = 10.66.83.193
                        remote_esx = 10.66.106.24
                        remote_password = 123qweP
                        cdrom_cd1 = isos/linux/RHEL-6.4-x86_64-DVD.iso
                        md5sum_cd1 = f56ee67421192973c7d761fc7ab43de5
                        md5sum_1m_cd1 = cc373dc662bbeda48504567f1d18e831
                        sha1sum_cd1 = c39e93539aa0c1b9f503190488f8073c04d394c5
                        sha1sum_1m_cd1 = e2d49dc3fbe17a6b2ba1812543f2cc08ef9565c4
                        unattended_file = unattended/RHEL-6-series.ks
                        floppies = "fl"
                        floppy_name = images/rhel-6.4-x86_64/esx_unattended.flp
            
            
                    # Only perform a libvirt import. No cdroms, no floppies, no nothing
                    - import:
                        virt_test_type = libvirt
                        no cdrom, url, nfs, remote_ks, pxe, kernel_initrd
                        cdroms = ""
                        floppy = ""
                        timeout = 180
            
                variants:
                    # Install guest from cdrom
                    - cdrom:
                        # TODO: is this needed for both kvm and libvirt?
                        # This option is only used in windows installation case,
                        # since linux use kernel/initrd option of qemu.
                        boot_once = d
                        medium = cdrom
                        redirs += " esx_unattended"
                    # Install guest from http/ftp url
                    - url:
                        only Linux
                        medium = url
                        url = REPLACE_THIS_WITH_TREE_URL
                    # Install guest from nfs nfs_server:nfs_dir
                    - nfs:
                        only Linux
                        medium = nfs
                        nfs_server = REPLACE_THIS_WITH_NFS_SERVER
                        nfs_dir = REPLACE_THIS_WITH_NFS_DIRECTORY
                    # Install guest with a remote kickstart
                    - remote_ks:
                        only Linux
                        medium = url
                        # TODO: does kvm need to prefix this with '--append'?
                        extra_params = " ks=REPLACE_THIS_WITH_URL_OF_KS"
                        url = REPLACE_THIS_WITH_TREE_URL
                    # Install guest using pxe/tftp  (virt-install --pxe)
                    - pxe:
                        only Linux
                        medium = pxe
                    # Install guest using kernel/initrd pair from directory
                    - kernel_initrd:
                        only Linux
                        medium = kernel_initrd
                    - import:
                        virt_test_type = libvirt
                        no extra_cdrom_ks, in_cdrom_ks, http_ks, floppy_ks
                        medium = import
                        force_create_image = no
                        create_image = no
            # Drop-in test - auto generated snippet
            - uptime:
                virt_test_type = esx
                virt_test_type = esx
                type = uptime
    - autotest: install setup image_copy unattended_install.cdrom
        no JeOS
        virt_test_type = qemu libvirt
        only Linux
        type = autotest_control
        test_timeout = 1800
        variants:
            - sleeptest:
                test_timeout = 120
                test_control_file = sleeptest.control
            - dbench:
                test_control_file = dbench.control
            - bonnie:
                test_control_file = bonnie.control
            - ebizzy:
                test_control_file = ebizzy.control
            - ffsb:
                test_control_file = ffsb.control
            - stress:
                test_control_file = stress.control
            - disktest:
                test_control_file = disktest.control
            - ctcs:
                # If you think this is too lengthy, please change the cerberus
                # control file and set this timeout appropriately.
                test_timeout = 3900
                test_control_file = ctcs.control
            - npb:
                test_control_file = npb.control
            - hackbench:
                test_control_file = hackbench.control
            - cpu_hotplug:
                no RHEL.3.9
                no RHEL.4
                kill_vm = yes
                test_control_file = cpu_hotplug.control
            - monotonic_time:
                test_control_file = monotonic_time.control
            - tsc:
                test_control_file = tsc.control
            - hwclock:
                test_control_file = hwclock.control
            - rtc:
                test_control_file = rtc.control
            - iozone:
                test_timeout = 4200
                test_control_file = iozone.control
                profilers += " sar iostat "
                variants:
                    - aio_native:
                        image_aio = native
                    - aio_threads:
                        image_aio = threads
            - flail:
                test_control_file = flail.control
            - systemtap:
                test_control_file = systemtap.control
            - ltp:
                # This timeout has to be set inaccordance with timeout
                # argument in ltp.control (-t 1h)file.
                # Currently it is set to 1 hour and correspodingly this time
                # has been kept (3600+1000) 4600 seconds.
                # Inorder to run ltp for more time change the timeout here and
                # ltp.control file appropriately.
                test_timeout = 4600
                test_control_file = ltp.control
            - cpuflags-stress:
                test_control_file = cpuflags.control
            - scsi_testsuite:
                images += " asd"
                image_boot_image1 = yes
                image_name_asd = scsidisk
                image_format_asd = qcow2
                image_boot_asd = no
                drive_index_asd = 1
                create_image_asd = yes
                image_size_asd = 10M
                drive_serial_asd = ATST001
                pci_model = scsi
                test_control_file = scsi_testsuite.control
                variants:
                    - scsi-disk:
                        drive_format_asd = scsi-disk
            - xfstests:
                # Below packages requried to installed in guest before start test:
                # xfsdump, xfsprogs xfsprogs-devel
                no RHEL.3 RHEL.4 RHEL.5 RHEL.6
                kill_vm = yes
                images += " stg1"
                image_name_stg1 = "images/stg1"
                image_format_stg1 = "qcow2"
                image_size_stg1 = 2G
                force_create_image_stg1 = yes
                force_remove_image_stg1= yes
                test_timeout = 4800
                test_control_file = xfstests.control
            - linus_stress:
                test_control_file = linus_stress.control
            - signaltest:
                test_control_file = signaltest.control
            - parallel_dd:
                test_timeout = 36000
                images += " stg"
                image_format_stg = qcow2
                boot_drive_stg = yes
                image_name_stg = images/storage
                image_size_stg = 10G
                force_create_image_stg = yes
                test_control_file = parallel_dd.control
            - compliebench:
                test_control_file = compilebench.control
            - fsstress:
                test_timeout = 36000
                test_control_file = fsstress.control
            - aiostress:
                test_control_file = aiostress.control
                variants:
                    - aio_native:
                        image_aio = native
                    - aio_threads:
                        image_aio = threads
            - interbench:
                test_control_file = interbench.control
            - kernbench:
                test_control_file = kernbench.control
            - posixtest:
                test_timeout = 3600
                test_control_file = posixtest.control
            - rmaptest:
                test_control_file = rmaptest.control
            - synctest:
                test_control_file = synctest.control
            - tbench:
                test_control_file = tbench.control
            - tiobench:
                test_timeout = 4200
                test_control_file = tiobench.control
                variants:
                    - aio_native:
                        image_aio = native
                    - aio_threads:
                        image_aio = threads
            - fio:
               no RHEL.3 RHEL.4
               test_timeout =1800
               test_control_file = fio.control
            - unixbench5:
               no RHEL.3 RHEL.4
               test_timeout = 4200
               test_control_file = unixbench5.control
            - wb_kupdate:
               test_timeout =1800
               test_control_file = wb_kupdate.control
            - libhugetlbfs:
               no RHEL.3 RHEL.4
               test_control_file = libhugetlbfs.control
    - autotest_distro_detect: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = autotest_distro_detect
        test_timeout = 90
        distro_release = 0
        variants:
            - fedora_17_x86_64:
                only JeOS.17.x86_64, Fedora.17.x86_64
                distro_name = 'fedora'
                distro_version = 17
                distro_arch = 'x86_64'
    
            - fedora_18_x86_64:
                only Fedora.18.x86_64
                distro_name = 'fedora'
                distro_version = 18
                distro_arch = 'x86_64'
    
            - redhat_6_3_x86_64:
                only RHEL.6.3.x86_64
                distro_name = 'redhat'
                distro_version = 6
                distro_release = 3
                distro_arch = 'x86_64'
    
            - redhat_6_2_x86_64:
                only RHEL.6.2.x86_64
                distro_name = 'redhat'
                distro_version = 6
                distro_release = 2
                distro_arch = 'x86_64'
    - autotest_regression: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        master_images_clone = image1
        type = autotest_regression
        restart_vm = yes
        kill_vm_on_error = yes
        login_timeout = 240
        vms = "autotest_server_vm autotest_client_vm"
        autotest_install_timeout = 1800
        autotest_repo = git://github.com/autotest/autotest.git
        autotest_branch = next
        autotest_commit =
    
    - block_hotplug: install setup image_copy unattended_install.cdrom
        no RHEL.3.9
        virt_test_type = qemu libvirt
        type = pci_hotplug
        pci_type = block
        reference_cmd = lspci
        find_pci_cmd = 'lspci | tail -n1'
        images += " stg0"
        boot_drive_stg0 = no
        image_name_stg0 = images/storage0
        image_size_stg0 = 1G
        remove_image_stg0 = yes
        force_create_image_stg0 = yes
        pci_test_cmd = "echo %s; yes | mke2fs `fdisk -l 2>&1 | awk '/\/dev\/[sv]d[a-z]* doesn/ {print $2}'` | sort | tail -1"
        wait_secs_for_hook_up = 3
        kill_vm_on_error = yes
        variants:
            - fmt_qcow2:
                image_extra_params = ""
                image_format_stg = qcow2
                image_format_stg0 = qcow2
                image_format_stg1 = qcow2
            - fmt_raw:
                image_extra_params = ""
                image_format_stg = raw
                image_format_stg0 = raw
                image_format_stg1 = raw
        variants:
            - one_pci:
                pci_num = 1
                repeat_times = 300
            - multi_pci:
                pci_num = 2
                repeat_times = 2
                images += " stg1"
                boot_drive_stg1 = no
                image_name_stg1 = images/storage1
                image_size_stg1 = 1G
                remove_image_stg1 = yes
                force_create_image_stg1 = yes
        variants:
            - block_virtio:
                pci_model = virtio
                match_string = "Virtio block device"
            - block_scsi:
                pci_model = scsi
                match_string = "LSI Logic"
    - boot: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = boot
        restart_vm = yes
        kill_vm_on_error = yes
        login_timeout = 240
    - boot_savevm: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        no raw
        no raw_dd
        type = boot_savevm
        save_method = save_to_file
        savevm_delay = 0.3
        savevm_login_delay = 5
        savevm_timeout = 2000
        kill_vm_on_error = yes
        kill_vm_gracefully = yes
        kill_vm = yes
        variants:
            - default_savevm:
    
            - with_floppy:
                no Host_RHEL.7
                virt_test_type = qemu
                save_method = save_to_tag
                with_floppy = yes
                floppy_name = images/test.qcow2
                floppies = fl
                start_vm = no
                floppy_format = qcow2
    - clock_getres: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        no JeOS
        only Linux
        type = clock_getres
    - dd_test: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = dd_test
        images += " stg1"
        create_image_stg1 = yes
        image_name_stg1 = images/stg1
        image_size_stg1 = 1M
        image_snapshot_stg1 = no
        drive_index_stg1 = 3
        image_boot_stg1 = no
        dd_count = 1
        # last input and output disk
        dd_if_select = -1
        dd_of_select = -1
        variants:
            - readwrite:
                dd_stat = 0
                variants:
                    - zero2disk:
                        dd_if = ZERO
                        dd_of = /dev/[shv]d?
                    - disk2null:
                        dd_if = /dev/[shv]d?
                        dd_of = NULL
            - readonly:
                # ide, ahci don't support readonly disks
                no ide, ahci
                image_readonly_stg1 = yes
                variants:
                    - zero2disk:
                        dd_if = ZERO
                        dd_of = /dev/[shv]d?
                        dd_stat = 1
                    - disk2null:
                        dd_if = /dev/[shv]d?
                        dd_of = NULL
                        dd_stat = 0
    - ethtool:
        virt_test_type = qemu libvirt
        only Linux
        only e1000, virtio_net
        no RHEL.3
        type = ethtool
        filesize = 512
        nic_mode = tap
        e1000:
            # gso gro lro is only supported by latest kernel
            supported_features = "tx rx sg tso gso gro lro"
        virtio_net:
            supported_features = "tx sg tso gso"
        RHEL.4..e1000:
            supported_features = "tx rx sg tso"
        RHEL.4..virtio_net:
            supported_features = "tx sg tso"
        RHEL.5..e1000:
            supported_features = "tx rx sg tso gso"
    - fail_test:
        virt_test_type = libvirt qemu openvswitch v2v
        type = fail
        vms = ""
    - file_transfer: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = file_transfer
        filesize = 4000
        transfer_timeout = 1000
        variants:
            - remote:
                transfer_type = remote
        variants:
            - no_vhostforce:
            - vhostforce_off:
                netdev_extra_params_nic1 += ',vhostforce=off'
            - vhostforce_on:
                netdev_extra_params_nic1 += ',vhostforce=on'
    - fillup_disk: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        only qcow2
        type = fillup_disk
        fillup_timeout = 120
        fillup_size = 200
        fillup_cmd = "dd if=/dev/zero of=/%s/fillup.%d bs=%dM count=1 oflag=direct"
        kill_vm = yes
    - guest_suspend:
        no RHEL.3.9
        no RHEL.4
        type = guest_suspend
        services_up_timeout = 30
        kill_vm_on_error = yes
        variants:
            - @default:
                # New guests which support acpi on old hosts.
                only RHEL.6.3, RHEL.6.4
                only Host_RHEL.5, Host_RHEL.6.0, Host_RHEL.6.1, Host_RHEL.6.2
            - no_virtio:
                # Old guests which can't do s3/s4 with virtio device.
                no virtio_net
                no virtio_blk
                only RHEL.5, RHEL.6.0, RHEL.6.1, RHEL.6.2
                only Host_RHEL.5, Host_RHEL.6.0, Host_RHEL.6.1, Host_RHEL.6.2
            - global_disable_s3:
                only guest_s3
                no Host_RHEL.5, Host_RHEL.6.0, Host_RHEL.6.1, Host_RHEL.6.2
                negative_test = yes
                extra_params += " -global PIIX4_PM.disable_s3=1"
            - global_enable_s3:
                only guest_s3
                no RHEL.4, RHEL.5, RHEL.6.0, RHEL.6.1, RHEL.6.2
                no Host_RHEL.5, Host_RHEL.6.0, Host_RHEL.6.1, Host_RHEL.6.2
                extra_params += " -global PIIX4_PM.disable_s3=0"
            - global_disable_s4:
                only guest_s4
                no Host_RHEL.5, Host_RHEL.6.0, Host_RHEL.6.1, Host_RHEL.6.2
                # The iasl package isn't available on RHEL5 i386 platform.
                no RHEL.5.i386
                negative_test = yes
                extra_params += " -global PIIX4_PM.disable_s4=1"
            - global_enable_s4:
                only guest_s4
                no RHEL.4, RHEL.5, RHEL.6.0, RHEL.6.1, RHEL.6.2
                no Host_RHEL.5, Host_RHEL.6.0, Host_RHEL.6.1, Host_RHEL.6.2
                extra_params += " -global PIIX4_PM.disable_s4=0"
        variants:
            - @default:
            - with_kvmclock:
                no Windows
                type = clock_getres
                sub_test = guest_suspend
            - without_kvmclock:
                cpu_model_flags += ",-kvmclock"
        variants:
            - guest_s3:
                guest_suspend_type = "mem"
                services_up_timeout = 30
                # params: s3_support_chk_cmd, s3_bg_program_setup_cmd,
                # s3_bg_program_chk_cmd, s3_bg_program_kill_cmd, s3_log_chk_cmd,
                # s3_start_cmd and services_up_timeout are set in guest-os.cfg
            - guest_s4:
                guest_suspend_type = "disk"
                # params: s4_support_chk_cmd, s4_bg_program_setup_cmd,
                # s4_bg_program_chk_cmd, s4_bg_program_kill_cmd, s4_log_chk_cmd,
                # s4_start_cmd and services_up_timeout are set in guest-os.cfg
    - guest_test: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Windows
        type = guest_test
        login_timeout = 360
        test_timeout = 600
        script_params =
        reboot = yes
        variants:
            - autoit:
                interpreter = "cmd /c D:\AutoIt3.exe"
                variants:
                    - notepad:
                        guest_script = autoit/notepad1.au3
                        dst_rsc_path = "C:\script.au3"
                    - stub:
                        download = yes
                        download_cmd = "git clone"
                        rsc_server = "git://the.resource.server/autoit"
                        dst_rsc_dir = "C:\"
                        dst_rsc_path = "C:\autoit\stub\stub.au3"
            - powershell:
                interpreter = "cmd /c powershell.exe -File"
                variants:
                    - stub:
                        download = yes
                        download_cmd = "git clone"
                        rsc_server = "git://the.resource.server/powershell"
                        dst_rsc_dir = "C:\"
                        dst_rsc_path = "C:\powershell\stub\stub.ps1"
    - iofuzz: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = iofuzz
    
    - iometer_windows:
        only Windows
        type = iometer_windows
        images += " disk1"
        drive_index_disk1 = 2
        boot_drive_disk1 = yes
        image_name_disk1 = images/storage
        image_size_disk1 = 1G
        force_create_image_disk1 = yes
        writefile_cmd = echo
        kill_vm = yes
        cmd_timeout = 1200
        cdrom_cd1 = "isos/windows/winutils.iso"
        icf_name = "iometer.icf"
        install_cmd = "cmd /c WIN_UTILS:\autoit3.exe WIN_UTILS:\Iometer\iometer.au3"
        install_path = "C:\Iometer"
        register_cmd = "cmd /c WIN_UTILS:\autoit3.exe WIN_UTILS:\Iometer\iometer-reg.au3"
        result_file = "C:\autotest_iometer_result.csv"
        run_cmd = "cmd /c Iometer.exe /c %s /r %s"
    
        # configuration form format disk:
        create_partition_cmd = "echo select disk 1 > cmd &&"
        create_partition_cmd += " echo create partition primary >> cmd &&"
        create_partition_cmd += " echo select partition 1 >> cmd &&"
        create_partition_cmd += " echo assign letter=I >> cmd &&"
        create_partition_cmd += " echo exit >> cmd &&"
        create_partition_cmd += " diskpart /s cmd"
        format_cmd = "format I: /FS:NTFS /V:local /Q /y"
        list_disk_cmd = "echo list disk >  cmd &&"
        list_disk_cmd += " echo exit >>  cmd &&"
        list_disk_cmd += " diskpart /s cmd"
        set_online_cmd = " echo select disk %s > cmd &&"
        set_online_cmd += " echo online disk >> cmd &&"
        set_online_cmd += " echo att disk clear readonly >> cmd &&"
        set_online_cmd += " echo exit >> cmd &&"
        set_online_cmd += " diskpart /s cmd"
        readfile_cmd = "type"
        mount_cmd =
        variants:
            - @default:
                run_timeout = 1000
                variants:
                    - aio_native:
                        image_aio = native
                    - aio_threads:
                        image_aio = threads
            - performance:
                run_timeout = 23400
                icf_name = "iometer-performance.icf"
                variants:
                    - msi_on:
                        cpu_family = "0xf"
                    - msi_off:
                        cpu_family = "0xe"
    - ioquit: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = ioquit
        background_cmd = "for i in 1 2 3 4; do (dd if=/dev/urandom of=/tmp/file bs=102400 count=10000000 &); done"
        check_cmd = ps -a | grep dd
        login_timeout = 360
    - iozone_windows: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Windows
        type = iozone_windows
        cdrom_cd1 = isos/windows/winutils.iso
        iozone_cmd = "%s:\iozone\iozone -azR -r 64k -n 1G -g 4G -M -b iozone.xls -f c:\testfile"
        iozone_timeout = 7200
        mem = 2048
        variants:
            - aio_native:
                image_aio = native
            - aio_threads:
                image_aio = threads
    - jumbo: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        no RHEL.3.9
        no RHEL.4
        requires_root = yes
        type = jumbo
        rtl8139, spapr-vlan:
            mtu = 1500
        e1000:
            Linux:
                mtu = 16110
            Windows:
                 mtu_key = *jumbopacket
                 mtu = 16128
                 Win2003:
                    mtu = 1500
        virtio_net:
            Linux:
                mtu = 65520
            Windows:
                mtu_key = MTU
                mtu = 65500
    - kdump: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only RHEL.5, RHEL.6
        type = kdump
        # time waited for the completion of crash dump
        crash_timeout = 1200
        # command to add the crashkernel=X@Y to kernel cmd line
        # kernel_param_cmd = "grubby --update-kernel=`grubby --default-kernel` --args=crashkernel=128M@64M"
        # command to enable kdump service
        # kdump_enable_cmd = chkconfig kdump on && service kdump start
        # command to probe the crash kernel
        # crash_kernel_prob_cmd = "grep -q 1 /sys/kernel/kexec_crash_loaded"
        # crash_cmd = "echo c > /proc/sysrq-trigger"
        # If you want configure multiline, split lines with ";", like:
        # kdump_config = configure line1; config line2
        RHEL.5:
            kdump_config = core_collector makedumpfile -c -d 31
        variants:
            - @default:
            - nmi:
                kernel_param_cmd = "grubby --update-kernel=`grubby --default-kernel` --args='crashkernel=128M nmi_watchdog=1'"
                crash_cmd = nmi
    - linux_s3: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = linux_s3
    - lvm: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        images += ' stg1 stg2'
        image_name_stg1 = images/storage_4k
        image_cluster_size_stg1 = 4096
        image_size_stg1 = 1G
        image_format_stg1 = qcow2
        image_name_stg2 = images/storage_64k
        image_cluster_size_stg2 = 65536
        image_size_stg2 = 1G
        image_format_stg2 = qcow2
        guest_testdir = /mnt
        disks = "/dev/sdb /dev/sdc"
        kill_vm = no
        post_command_noncritical = no
        variants:
            - lvm_create:
                type = lvm
                force_create_image_stg1 = yes
                force_create_image_stg2 = yes
                clean = no
            - lvm_fill: lvm_create
                type = fillup_disk
                force_create_image_stg1 = no
                force_create_image_stg2 = no
                guest_testdir = /mnt/kvm_test_lvm
                fillup_timeout = 120
                fillup_size = 20
                fillup_cmd = "dd if=/dev/zero of=%s/fillup.%d bs=%dM count=1 oflag=direct"
            - lvm_ioquit: lvm_create
                type = ioquit
                force_create_image_stg1 = no
                force_create_image_stg2 = no
                kill_vm = yes
                background_cmd = "for i in 1 2 3 4; do (dd if=/dev/urandom of=/mnt/kvm_test_lvm/file bs=102400 count=10000000 &); done"
                check_cmd = pgrep dd
                clean = yes
                remove_image_stg1 = yes
                remove_image_stg2 = yes
    - mac_change: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = mac_change
        kill_vm = yes
        variants:
            - down_change:
                only Linux
                shutdown_int = yes
                int_shutdown_cmd = ifconfig %s down
                int_activate_cmd = ifconfig %s up
            - @up_change:
                virtio_net:
                    no RHEL.5, RHEL.6.0, RHEL.6.1, RHEL.6.2, RHEL.6.3
                shutdown_int = no
    - module_probe:
        virt_test_type = qemu
        type = module_probe
        requires_root = yes
        # You can specify your own module list, though it is not needed usually.
        # mod_list = kvm
        load_count = 100
        vms = ''
        profilers = ''
        take_regular_screendumps = no
    - multi_queues_test: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = multi_queues_test
        queues = 4
        enable_msix_vectors = yes
        netperf_version = 2.6.0
        netperf_download_link = ftp://ftp.netperf.org/netperf/netperf-2.6.0.tar.bz2
        pkg_md5sum = 9654ffdfd4c4f2c93ce3733cd9ed9236
        setup_cmd = "cd %s && rm -rf netperf-2.6.0 && tar xvfj netperf-2.6.0.tar.bz2 >/dev/null && cd netperf-2.6.0 && ./configure --enable-burst --enable-demo=yes >/dev/null  && make >/dev/null"
        tmp_dir = /home
        vhost = "vhost=on"
        instance = 2
        variants:
            - smp1:
                no smp2
                smp = 1
            - smpN:
                no smp2
                smp = 4
            - max_queue:
                queues = 8
                smp = 8
            - cpu_affinity:
               #this test smp must equal queues.
               smp = 4
               queues = 4
               instance = 1
               netperf_taskset_cpu = 0
               check_cpu_affinity = yes
            - invalid_queues_number:
               start_vm = no
               type = invalid_para_mq
               queues = 9
    - multicast: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = multicast
        mcast = 225.0.0.1
        mgroup_count = 20
        flood_minutes = 1
    - netperf: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = netperf
        kill_vm = yes
        image_snapshot = yes
        # Please update following comments params when you need special cfg for
        # your test nic cards
        # nic1 is for control, nic2 is for data connection
        nics += ' nic2'
        #Configure different types of network adapters.
        nic_model_nic1 = virtio
        nic_model_nic2 = e1000
        netdst_nic1 = private
        netdst_nic2 = switch
        # please fix the mac for nic2 if you needed with this, this can be empty
        # nic_mac_nic2 =
        # please add the physical nic you want to add to your private bridge
        # this can be empty
        # physical_nic =
        # bridge_force_create=yes
        # bridge_nic1 =
        #numa configration
        numa_node = -1
        netperf_with_numa = yes
        # configure netperf test parameters, some seconds will be took to
        # wait all the clients work, this wait time should be less than
        # 0.5 * l, the wait time will augments if you have move
        # threads. So experientially suggest l should be not less than 60.
        l = 60
        #need modify the netperf_start_timeout, if you adjust the value of l
        netperf_start_timeout = 360
        #Test protocol and test data configration
        protocols = "TCP_STREAM TCP_MAERTS TCP_RR TCP_CRR"
        sessions = "1 2 4"
        sessions_rr = "50 100 250 500"
        sizes = "64 256 512 1024"
        sizes_rr = "64 256 512 1024"
        #client configuration
        client = localhost
        username_client = root
        password_client = 123456
        shell_client_client = ssh
        shell_port_client = 22
        shell_prompt_client =  \[root@.{0,50}][\#\$]
        #host configuration
        shell_port_host = 22
        password_host = 123456
        username_host = root
        os_type_client = linux
        os_type_host = linux
        shell_prompt_host =  \[root@.{0,50}][\#\$]
        #Test base env configration
        ver_cmd = rpm -qa |grep kvm
        netperf_version = 2.6.0
        netperf_download_link = ftp://ftp.netperf.org/netperf/netperf-2.6.0.tar.bz2
        pkg_md5sum = 9654ffdfd4c4f2c93ce3733cd9ed9236
        setup_cmd = "cd /tmp && rm -rf netperf-2.6.0 && tar xvfj netperf-2.6.0.tar.bz2 && cd netperf-2.6.0 && ./configure --enable-burst --enable-demo=yes && make"
        variants:
            - guest_guest:
                no Jeos
                only Linux
                client = vm2
                vms += " vm2"
                nics = 'nic1'
            - host_guest:
                Windows:
                    netserv_start_cmd = "start /b %s:\netserver-2.6.0.exe"
                    guest_ver_cmd = "ver"
                    use_cygwin = no
                variants:
                    - @default_setting:
                        Linux:
                            no Jeos
                            # to test exthost <-> guest:
                            # client = <external host ip>
                        Windows:
                            #client = <external host/guest ip>
                    - best_registry_setting:
                        only Windows
                        reboot_after_config = yes
                        # For more information about windows registry setting document,
                        #please refer to http://www.linux-kvm.org/page/WindowsGuestDrivers/kvmnet/registry
                        config_cmds = afd_cmd1,afd_cmd2,afd_cmd3, tcpip_cmd1,tcpip_cmd2
                        afd_cmd1 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\AFD\Parameters" /v DefaultSendWindow /d 0x00100000 /t REG_DWORD /f
                        afd_cmd2 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\AFD\Parameters" /v DefaultReceiveWindow /d 0x00100000 /t REG_DWORD /f
                        afd_cmd3 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\AFD\Parameters" /v FastSendDatagramThreshold /d 0x00004000 /t REG_DWORD /f
                        tcpip_cmd1 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters" /v Tcp1323Opts /d 0x00000001 /t REG_DWORD /f
                        tcpip_cmd2 = reg add "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters" /v TcpWindowSize /d 0x00100000 /t REG_DWORD /f
                        disable_tcp_heuristics_cmd = "netsh int tcp set heuristics disabled"
                        disabled_tcp_autotuning_cmd = "netsh int tcp set global autotuninglevel=disabled"
                        enable_ctcp_cmd = "netsh int tcp set global congestionprovider=ctcp"
                        Win2008, Win2008r2, Win7:
                            config_cmds += ,disable_tcp_heuristics_cmd,disabled_tcp_autotuning_cmd,enable_ctcp_cmd
                    - cygwin:
                        only Windows
                        use_cygwin = yes
                        netperf_src = %s:\netperf\netperf-2.6.0
                        cygwin_root = C:\rhcygwin\home\Administrator
                        netserver_path = C:\rhcygwin\usr\local\bin
                        cygwin_start = C:\rhcygwin\Cygwin.bat -i /Cygwin-Terminal.ico -
                        netserv_start_cmd = netserver
                        netperf_install_cmd = cd netperf-2.6.0; ./configure --enable-burst --enable-demo=yes; make; make install
    - netstress_kill_guest: install setup unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = netstress_kill_guest
        image_snapshot = yes
        nic_mode = tap
        nic_module_cmd = "readlink /sys/class/net/*/device/driver/module"
        RHEL.4.9:
            nic_module_cmd = "readlink /sys/class/net/*/driver"
        # There should be enough vms for build topology.
        variants:
            -driver:
                mode = driver
            -load:
                mode = load
                netperf_files = netperf-2.6.0.tar.bz2
                packet_size = 1500
                setup_cmd = "cd %s && rm -rf netperf-2.6.0 && tar xvfj netperf-2.6.0.tar.bz2 && cd netperf-2.6.0 && ./configure --enable-burst && make"
                clean_cmd = " while killall -9 netserver; do True test; done;"
                netserver_cmd = %s/netperf-2.6.0/src/netserver
                netperf_cmd = %s/netperf-2.6.0/src/netperf -t %s -H %s -l 60 -- -m %s
    - nfs_corrupt:
        only Linux
        virt_test_type = qemu libvirt
        type = nfs_corrupt
        requires_root = yes
        start_vm = no
        images += " stg"
        image_size_stg = "10G"
        image_format_stg = "qcow2"
        create_image_stg = no
        force_create_image_stg = no
        remove_image_stg = yes
        drive_werror = stop
        drive_cache = none
        kill_vm = yes
        post_command_noncritical = yes
        wait_paused_timeout = 120
        nfs_stat_chk_re = "running"
    - nic_promisc: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = nic_promisc
        filesize = 400
        transfer_timeout = 100
        transfer_type = remote
    - nicdriver_unload: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = nicdriver_unload
        filesize = 512
        transfer_timeout = 1000
        sessions_num = 5
    - ntttcp:
        virt_test_type = qemu libvirt
        only Windows
        type = ntttcp
        image_snapshot = yes
        check_ntttcp_cmd = "cmd /c dir C:\NTttcp"
        ntttcp_sender_cmd = "cmd /c C:\NTttcp\NTttcps.exe -m %s,0,%s -a 2 -l %s -n %s"
        ntttcp_receiver_cmd = "cmd /c C:\NTttcp\NTttcpr.exe -m %s,0,%s -a 6 -rb %s -n %s"
        session_num = 1
        buffers = "2k 4k 8k 16k 32k 64k 128k 256k 512k 1024k 2048k"
        timeout = 1200
        kill_vm = yes
        numa_node = -1
        variants:
            - guest_guest:
                vms += " vm2"
            - guest_host:
                # external Windows system IP, NTttcp need to be installed firstly.
                receiver_address = "192.168.1.1"
        i386:
            ntttcp_install_cmd = 'cmd /c "D:\autoit3.exe D:\NTttcp\NTttcp.au3 && mkdir C:\NTttcp && copy "C:\Program Files\Microsoft Corporation\NT Testing TCP Tool\*" C:\NTttcp && cd C:\NTttcp\ && copy NTttcp_%s.exe NTttcps.exe && copy NTttcp_%s.exe NTttcpr.exe"'
        x86_64:
            ntttcp_install_cmd = 'cmd /c "D:\autoit3.exe D:\NTttcp\NTttcp.au3 && mkdir C:\NTttcp && copy "C:\Program Files (x86)\Microsoft Corporation\NT Testing TCP Tool\*" C:\NTttcp && cd C:\NTttcp\ && copy NTttcp_%s.exe NTttcps.exe && copy NTttcp_%s.exe NTttcpr.exe"'
    - ping: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = ping
        counts = 100
        flood_minutes = 10
        variants:
            - default_ping:
            - multi_nics:
                no Windows
                nics += ' nic2'
            - ext_host:
                ping_ext_host = "yes"
                ext_host_get_cmd = "ip route | awk '/default/ { print $3 }'"
    - pxe:
        virt_test_type = qemu libvirt
        type = pxe
        requires_root = yes
        images = pxe
        image_name_pxe = images/pxe-test
        image_size_pxe = 1G
        force_create_image_pxe = yes
        remove_image_pxe = yes
        boot_once = n
        kill_vm_on_error = yes
        network = bridge
        restart_vm = yes
        pxe_timeout = 60
        image_verify_bootable = no
        variants:
            - @default:
            - etherboot:
                pre_command = "alternatives --display qemu-pxe-roms |grep -q etherboot && alternatives --set 'qemu-pxe-roms' /usr/share/etherboot || true"
                no Host_RHEL.6
            - gpxe:
                pre_command = "alternatives --display qemu-pxe-roms |grep -q gpxe || alternatives --install /usr/share/qemu-pxe-roms qemu-pxe-roms /usr/share/gpxe 1; alternatives --set 'qemu-pxe-roms' /usr/share/gpxe"
            - with_query_cpus:
                type = pxe_query_cpus
                start_vm = no
                restart_vm = no
                enable_mmu_cmd_ept = "modprobe -r kvm_intel; modprobe kvm_intel ept=1"
                check_mmu_cmd_ept = "grep -i Y /sys/module/kvm_intel/parameters/ept"
                restore_mmu_cmd_ept = "modprobe -r kvm_intel && modprobe kvm_intel"
                enable_mmu_cmd_npt = "modprobe -r kvm_amd; modprobe kvm_amd npt=1"
                enable_mmu_cmd_npt = "grep -i 1 /sys/module/kvm_amd/parameters/npt"
                restore_mmu_cmd_npt = "modprobe -r kvm_amd && modprobe kvm_amd"
    - reboot: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = boot
        reboot_method = shell
        kill_vm_on_error = yes
        login_timeout = 240
        reboot_count = 25
        # this script is used to setup test env for (linux)guest/host
        # before performance testing
        # rh_perf_envsetup_script = scripts/rh_perf_envsetup.sh
    - save_restore: install setup image_copy boot
        only Linux
        virt_test_type = qemu libvirt
        type = save_restore
        # Number of times to repeat save/restore
        save_restore_repeat = 1
        # Seconds to allow for guest runtime
        save_restore_start_delay = 4.0
        # Seconds to wait before restoring guest
        save_restore_delay = 1.0
        # Maximum time test allowed to run
        save_restore_duration = 60.0
        # Guest command to run, e.g.: Keep one CPU busy and memory dirty.
        # Note: Command will be backgrounded by appending a '&'
        save_restore_bg_command = '( mkdir -p /x && mount -t tmpfs -o size=75% x /x && while true; do dd if=/dev/urandom of=/x/x; done; umount /x && rmdir /x )'
        save_restore_path = "/tmp"
        kill_unresponsive_vms = no
        restart_vm = no
        kill_vm = yes
        variants:
            # Tests assumed to include install and boot before,
            # and a shutdown after the lifecycle test
            - lifecycle_short: unattended_install.cdrom boot
                save_restore_repeat = 25
                save_restore_duration = 1200.0
            - lifecycle_medium: unattended_install.cdrom boot
                save_restore_repeat = 50
                save_restore_delay = 1.0
                save_restore_duration = 2600.0
            - lifecycle_long: unattended_install.cdrom boot
                save_restore_repeat = 100
                save_restore_duration = 5400.0
    - skip_test:
        virt_test_type = libvirt qemu openvswitch v2v
        type = skip
        vms = ""
    - stop_continue: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        type = stop_continue
        kill_vm_on_error = yes
        variants:
            - stop_cont_only:
    
            - with_file_copy:
                prepare_op = "dd if=/dev/urandom of=/tmp/origin bs=1M count=1024"
                prepare_op_timeout = 240
                start_bg_process = yes
                bg_cmd = "rm -rf /tmp/new; cp /tmp/origin /tmp/new"
                check_op = "i=`md5sum /tmp/origin | awk '{print $1}'`; j=`md5sum /tmp/new | awk '{print $1}'`;echo $j|grep $i"
                clean_op = "rm -rf /tmp/origin /tmp/new"
    - stress_boot: install setup image_copy unattended_install.cdrom
        virt_test_type = libvirt qemu
        type = stress_boot
        max_vms = 5
        alive_test_cmd = uname -a
        login_timeout = 240
        kill_vm = yes
        kill_vm_vm1 = no
        kill_vm_gracefully = no
        extra_params += " -snapshot"
        used_cpus = 5
        used_mem = 2560
    - timedrift: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        rtc_drift = "slew"
        variants:
            - shared_ntp_date:
                variants:
                    - with_load:
                        type = timedrift
                        # Pin the VM and host load to CPU #0
                        cpu_mask = 0x1
                        # Set the load and rest durations
                        load_duration = 20
                        rest_duration = 20
                        # Fail if the drift after load is higher than 50%
                        drift_threshold = 50
                        # Fail if the drift after the rest period is higher than 10%
                        drift_threshold_after_rest = 10
                        # For now, make sure this test is executed alone
                        used_cpus = 100
                        variants:
                            - default_load:
                            - full_load:
                                test_duration = 28800
                                interval_gettime = 1800
                                pre_command = touch /tmp/host_load_timedrift; for (( I=0; I<`grep -c 'processor' /proc/cpuinfo`; I++ )); do echo $I;taskset -c $I /bin/bash -c 'while [ -e /tmp/host_load_timedrift ]; do :; done&'; done
                                post_command = rm -f /tmp/host_load_timedrift
                    - with_migration:
                        type = timedrift_with_migration
                        migration_iterations = 3
                        drift_threshold = 10
                        drift_threshold_single = 3
                    - with_reboot:
                        type = timedrift_with_reboot
                        reboot_iterations = 1
                        drift_threshold = 10
                        drift_threshold_single = 3
                    - with_stop:
                        type = timedrift_with_stop
                        stop_interations = 1
                        drift_threshold = 10
                        drift_threshold_single = 3
                variants:
                    - ntp:
                        no JeOS
                    - date:
    
            - monotonicity:
                type = timedrift_monotonicity
                cmd_get_time = "date +%s%N"
                time_linger = 60
                host_path = "/tmp/timedrift-monotonicity-result.txt"
                cmd_timeout = 100
                kill_vm_on_error = yes
                # can use this cmd to load host in timedrift testing
                # pre_command = for(( I=0; I<`cat /proc/cpuinfo | grep processor | wc -l`;I++)) ;do echo $I; taskset -c $I /bin/bash -c 'for ((;;)); do X=1;done &'; done
                variants:
                    - @short_linger:
                    - long_linger:
                        time_linger = 1800
            - with_cpu_offline:
                no Windows
                type = timedrift_with_cpu_offline
                offline_cpu_cmd = echo 0 > /sys/devices/system/cpu/cpu1/online
                online_cpu_cmd = echo 1 > /sys/devices/system/cpu/cpu1/online
                interval_gettime = 120
                test_duration = 600
                smp_min =2
            - with_signal_stop:
                no RHEL.3.9
                no RHEL.4
                type = timedrift_with_stop
                stop_interations = 1
                stop_with_signal = yes
        variants:
            - no_pvclock:
                no RHEL.5
            - with_pvclock:
                boot_option_added = "divider=10"
                only RHEL.5
    - trans_hugepage: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        requires_root = yes
        thp_test_config = ""
        kill_vm = yes
        login_timeout = 360
        setup_thp = yes
        variants:
            - base:
                type = trans_hugepage
                dd_timeout = 900
            - defrag:
                type = trans_hugepage_defrag
            - swapping:
                type = trans_hugepage_swapping
                dd_timeout = 900
                check_cmd_timeout = 900
            - relocated:
                type = trans_hugepage_relocated
                thp_test_config = "/sys/kernel/mm/redhat_transparent_hugepage/khugepaged/pages_to_scan:4096;/sys/kernel/mm/redhat_transparent_hugepage/khugepaged/scan_sleep_millisecs:10000;/sys/kernel/mm/redhat_transparent_hugepage/khugepaged/alloc_sleep_millisecs:60000"
            - migration:
                type = migration
                migration_test_command = help
                migration_bg_command = "mkdir -p /space; mount -t tmpfs none /space; while true; do dd if=/dev/zero of=/space/zero bs=4M count=1M;done"
                migration_bg_check_command = "pidof dd"
                migration_bg_kill_command = "killall dd"
            - memory_stress:
                type = trans_hugepage_memory_stress
                thp_memory_stress = autotest_control
                test_name = stress_memory_heavy
                test_control_file = stress_memory_heavy.control
                test_timeout = 600
                qemu_mem = 128
                hugetlbfs_path = "/proc/sys/vm/nr_hugepages"
    - vlan: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Linux
        type = vlan
        # subnet should not be used by host
        subnet = "192.168"
        vlan_num = 5
        file_size = 10
        maximal = 4094
        listen_cmd = "nc -l %s > %s"
        send_cmd = "nc %s %s < %s"
        vms += " vm2"
        image_snapshot = yes
        kill_vm_vm2 = yes
        kill_vm_gracefully_vm2 = no
        cmd_type = ip
        RHEL.5:
            cmd_type = vconfig
    - warning_test:
        virt_test_type = libvirt qemu openvswitch v2v
        type = warning
        vms = ""
    - whql: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Windows
        # Replace this with the address of an installed DTM server
        server_address = 10.20.30.40
        # The server should run rss.exe like a regular Windows VM, preferably
        # with administrator privileges (or at least with permission to write
        # to the DTM studio directory)
        server_shell_port = 10022
        server_file_transfer_port = 10023
        server_studio_path = %programfiles%\Microsoft Driver Test Manager\Studio
        dsso_test_binary = deps/whql_submission_15.exe
        dsso_delete_machine_binary = deps/whql_delete_machine_15.exe
        wtt_services = wttsvc
        variants:
            - support_vm_install:
                # The support VM is identical to the tested VM in every way
                # except for the image name which ends with '-supportvm'.
                type = unattended_install
                image_name += -supportvm
                boot_once = d
                force_create_image = yes
                kill_vm = yes
                redirs += " unattended_install"
                guest_port_unattended_install = 12323
                medium = cdrom
                kernel =
                initrd =
            - client_install:    support_vm_install
                type = whql_client_install
                # The username and password are required for accessing the DTM client
                # installer binary shared by the server
                server_username = administrator
                server_password = 1q2w3eP
                # This path refers to a shared directory on the server
                # (the final cmd will be something like \\servername\DTMInstall\...)
                install_cmd = \DTMInstall\Client\Setup.exe /passive
                install_timeout = 3600
                # The test will setup auto logon on the client machine using the
                # following username and password:
                client_username = DTMLLUAdminUser
                client_password = Testpassword,1
                # (These are created by the DTM client installer and should probably not
                # be changed.)
                variants:
                    - @original:
                    - support_vm:
                        image_name += -supportvm
            - submission:    client_install support_vm_install
                type = whql_submission
                extra_params += " -snapshot"
                restart_vm = yes
                cdroms =
                test_timeout = 3600
                device_data = cat0 cat1 cat2 cat3 prog desc virt filter logoarch logoos whqlos whqlqual
                descriptors = desc1 desc2 desc3
                # DeviceData names
                dd_name_cat0     = Category
                dd_name_cat1     = Category
                dd_name_cat2     = Category
                dd_name_cat3     = Category
                dd_name_logoarch = LogoProcessorArchitecture
                dd_name_logoos   = LogoOperatingSystem
                dd_name_whqlos   = WhqlOs
                dd_name_whqlqual = WhqlQualification
                dd_name_prog     = LogoProgramId
                dd_name_desc     = LogoProgramDescription
                dd_name_filter   = WDKFilterAttribute
                dd_name_virt     = ParaVirtualizationDriver
                # Common DeviceData data
                dd_data_filter   = FilterIfNoInf
                dd_data_virt     = True
                # Exclude jobs that have '(Manual)' in their names
                job_filter = ^((?!\(Manual\)).)*$
                variants:
                    - unclassified:
                        dd_data_cat0 = Device Fundamentals
                        dd_data_cat1 = System Fundamentals\Dynamic Partitioning
                        dd_data_prog = Unclassified
                        dd_data_desc = Unclassified
                        dd_data_whqlqual = Unclassified Signature
                        variants:
                            - tablet:
                                submission_name = tablet
                                extra_params += " -usbdevice tablet"
                                test_device = HID-compliant mouse
                                test_timeout = 36000
                    - device:
                        variants:
                            - keyboard:
                                submission_name = keyboard
                                # test_device is a regular expression that should match a device's
                                # name as it appears in device manager.  The first device that matches
                                # is used.
                                test_device = keyboard
                                # Set timeout to 10 hours
                                test_timeout = 36000
                                dd_data_cat0 = Input\Keyboard
                                dd_data_cat1 = Device Fundamentals
                                dd_data_cat2 = System Fundamentals\Dynamic Partitioning
                                dd_data_prog = InputKbd
                                dd_data_desc = Input > Keyboard
                            - net:
                                submission_name = net
                                # Add a support machine and extra NICs
                                vms += " supportvm"
                                nics += " nic2 nic3"
                                test_device = RTL8139.*NIC$
                                test_timeout = 86400
                                dd_data_cat0 = Network\LAN (Ethernet)
                                dd_data_cat1 = Device Fundamentals
                                dd_data_cat2 = System Fundamentals\Dynamic Partitioning
                                dd_data_prog = NetLan
                                dd_data_desc = Network > LAN (Ethernet)
                                # Machine dimensions
                                dimensions = testrole
                                dim_name_testrole = NetDevice\TestRole
                                dim_value_testrole_vm1 = NdistestLanClient
                                dim_value_testrole_supportvm = NdistestLanServer
                                # Device selection for the NDISTest client machine
                                device_params_vm1 = testdev clientmsgdev clientsupportdev
                                dp_name_testdev = NdistestLanClientTestDevice
                                dp_regex_testdev = RTL8139.*NIC$
                                dp_name_clientmsgdev = NdistestLanClientMessageDevice
                                dp_regex_clientmsgdev = RTL8139.*NIC #2$
                                dp_name_clientsupportdev = NdistestLanClientSupportDevice0
                                dp_regex_clientsupportdev = RTL8139.*NIC #3$
                                # Device selection for the NDISTest server machine
                                device_params_supportvm = servermsgdev serversupportdev
                                dp_name_servermsgdev = NdistestLanServerMessageDevice
                                dp_regex_servermsgdev = RTL8139.*NIC$
                                dp_name_serversupportdev = NdistestLanServerSupportDevice0
                                dp_regex_serversupportdev = RTL8139.*NIC #2$
                            - hdd:
                                submission_name = hdd
                                # Run the tests on a non-system drive
                                # (match device names that contain 'QEMU HARDDISK' and do not contain '[C]')
                                test_device = ^(?=.*?\bQEMU HARDDISK\b)((?!\[C\]).)*$
                                device_data += " ex0 ex1 ex2 ex3"
                                dd_data_cat0 = Storage\Device Class\Disk\Disk
                                dd_data_cat1 = Storage\Device Class\Disk\Fixed
                                dd_data_cat2 = Storage\Device Class\Disk\Bus\ATA
                                dd_data_cat3 = Device Fundamentals
                                dd_data_prog = StorHDD
                                dd_data_desc = Storage > Hard Disk Drive (HDD)
                                dd_name_ex0 = Storage_bus_type
                                dd_data_ex0 = ATA/ATAPI
                                dd_name_ex1 = Hybrid_HDD_Support
                                dd_data_ex1 = 0
                                dd_name_ex2 = Non_Rotating_Media
                                dd_data_ex2 = 0
                                dd_name_ex3 = Secure_Storage
                                dd_data_ex3 = 0
                                # Add a 2nd disk which will become D:
                                images += " tmp"
                                image_name_tmp = tmp
                                image_size_tmp = 4G
                                force_create_image_tmp = yes
                                # Run diskpart to partition the 2nd disk
                                whql_pre_command = "echo select disk=1 > dp.txt && "
                                whql_pre_command += "echo create partition primary >> dp.txt && "
                                whql_pre_command += "echo assign letter=d >> dp.txt && "
                                whql_pre_command += "diskpart /s dp.txt & "
                                whql_pre_command += "format d: /fs:ntfs /q /y"
                                variants:
                                    - full:
                                        # Yes, 100 hours, this is not a mistake
                                        test_timeout = 360000
                                    - syscache_test:
                                        job_filter = syscache test
                                        test_timeout = 7200
            - whql_env_setup:
                vms = ""
                type = whql_env_setup
                smp = 4
                rtc_drift = "slew"
                drive_werror = stop
                drive_rerror = stop
                cpu_family = "0xf"
                uuid = random
                force_create_image = yes
                force_create_image_image1 = no
                update_cmd = cmd /c D:\whql\wua_update.exe && cmd /c net stop wuauserv && cmd /c net start wuauserv && cmd /c D:\whql\WUInstall.exe /install /criteria "IsHidden=0 and IsInstalled=0 and IsAssigned=1" && dir
                auto_restart = "cmd /c regedit /s D:\whql\auto_restart_disable.reg"
                disable_uas =  "cmd /c regedit /s D:\whql\UAC_disable.reg"
                dbgview_cmd = "cmd /c D:\whql\dbgview_install.exe"
                setup_timeout = 9000
                disable_firewall = "netsh firewall set opmode mode=disable"
                disable_update = "net stop wuauserv"
                timezone_cmd = "tzutil /s "China Standard Time""
                # If you have some extra tools or scripts needed please put url or file list here. We will make a tmp iso here for running them inside guests
                # cdrom_whql = images/whql.iso
                # src_list =
                variants:
                    - nic_device:
                        nics += ' nic2 nic3'
                        nic_model = virtio
                        nic_model_nic1 = e1000
                        nic_config_cmd = "cmd /c D:\whql\whql_nic_set.exe"
                        nic_setup_params_nic2 = Init.MaxRxBuffers:256;Init.MaxTxBuffers:256
                        nic_setup_params_nic3 = Init.MaxRxBuffers:256;Init.MaxTxBuffers:256
    
                    - block_device:
                        image_snapshot = yes
                        images += " stg stg2 stg3 stg4"
                        image_extra_params = ""
                        image_format_stg = raw
                        image_name_stg = images/storage
                        image_size_stg = 2G
                        image_format_stg2 = raw
                        image_name_stg2 = images/storage2
                        image_size_stg2 = 2G
                        image_format_stg3 = raw
                        image_name_stg3 = images/storage3
                        image_size_stg3 = 2G
                        image_format_stg4 = raw
                        image_name_stg4 = images/storage4
                        image_size_stg4 = 2G
                        win_format_stg = NTFS
                        win_format_stg2 = NTFS
                        win_format_stg3 = FAT
                        win_format_stg4 = FAT32
                        win_extra_stg = "/c"
                        # symbol_files git repo is a git repo set up in your test env which include most of the symbol files
                        # We just need update the symbol files in guest which may save a lot of time.
                        # symbol_files =
                        debuggers_install = "cmd  /c D:\whql\dbg_install.bat"
                        symbol_file_download = "cmd /c C:\debuggers\symchk /r C:\windows\system32 /s SRV*C:\symbols\*http://msdl.microsoft.com/download/symbols & dir"
                        symbol_file_check = "cmd /c C:\debuggers\symchk C:\windows\system32\ntoskrnl.exe /s C:\symbols\"
                        symbol_check_pattern = "SYMCHK: FAILED files = 0"
                        symbol_pid_pattern = "symchk.*?PID:\s+(\d+)"
    
                        disk_driver_install = "cmd /c D:\whql\disk_driver_check.exe "
                        format_cmd = "format %s: /FS:%s /V:local /y"
                        disk_init_cmd = "echo select disk %s > cmd && echo create partition primary  >> cmd && echo select partition 1 >> cmd && echo assign letter=%s >> cmd && echo exit >> cmd && diskpart /s cmd"
    - yum_update: install setup image_copy unattended_install.cdrom
        virt_test_type = qemu libvirt
        only Fedora, RHEL
        type = yum_update
        shell_prompt = "Is this ok"
    # Drop-in test - auto generated snippet
    - build:
        virt_test_type = esx
        type = build
    # Auto generated snippet for dropin tests
    - dropin:
        variants:
    - shutdown: install setup image_copy unattended_install.cdrom
        virt_test_type = libvirt qemu
        type = shutdown
        shutdown_method = shell
        kill_vm = yes
        kill_vm_gracefully = no
